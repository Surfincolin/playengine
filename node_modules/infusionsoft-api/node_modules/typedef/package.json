{
  "name": "typedef",
  "version": "0.13.2",
  "description": "Familiar classes, mixins, and interfaces in ES5 Javascript. Member decorations for powerful objects that keep your code DRY",
  "main": "lib/typedef.js",
  "directories": {
    "test": "test"
  },
  "scripts": {
    "test": "grunt test"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:bvalosek/typedef.git"
  },
  "author": {
    "name": "Brandon Valosek"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "devDependencies": {
    "grunt": "~0.4.1",
    "grunt-contrib-uglify": "~0.2.2",
    "grunt-contrib-jshint": "~0.6.0",
    "grunt-contrib-watch": "~0.4.4",
    "grunt-browserify": "~1.2.0",
    "grunt-contrib-qunit": "~0.2.2"
  },
  "dependencies": {
    "underscore": "~1.5.1"
  },
  "readme": "# Typedef\n\n[![Build Status](https://travis-ci.org/bvalosek/typedef.png?branch=master)](https://travis-ci.org/bvalosek/typedef)\n\n**Typedef** is a lightweight library (1.7 KB, 4.7 KB with\n[underscore.js](http://www.underscorejs.org) bundled in) that brings some\nmuch-needed sanity to object-oriented programming in Javascript. These features\nwill feel very familiar and refreshing to anyone experienced in a more\ncivilized staticly-typed language like C# or Java.\n\n**Typedef** introduces two interesting concepts for Javascript: class member\ndecorations, and the idea of \"define-time\" (semi-static) checking. In addition\nit rolls in classical-style inheritance, interfaces, and mixins.\n\nThe goal is to let you build scalable web apps with a rich class hierarchy\nusing proven object-oriented concepts and semantics-enforcing constructs. Wed\nwith the dynamic nature of Javascript-- it's a potent mix.\n\nThe Javascript romantic in you may recoil and shout back about the virtues of\nembracing the native prototype-style inheritance model. This is\nunderstandable-- but if you can unburden yourself from the limitations you've\nbuilt around the language and keep an open mind... you're in for a wild ride.\n\n## Feature Overview\n\n* **Class inheritance.** Classical inheritance goodness in Javascipt. Create a\n  rich class hierarchy that feels sane, with all the power and common sense\n  you've come to expect in an object-oriented language.\n\n* **Mixins.** Add member functions to a class without enforcing a strict\n  single-inheritance relationships. The `before`, `after`, and `wrapped`\n  \"advice\" decorations can be used to modify existing functions.\n\n* **Interfaces.** Classical `interface` pattern lets you write code that is\n  self-documenting and forces define-time checks on code contracts.\n\n* **Member decorations.** Use modifiers on class members, mixin members, or\n  interface members to change their behavior or enforce inheritance and access\n  semantics, or use custom decorations and reflection to amp up your own\n  classes and reduce boilerplate.\n\n* **Define-time semantics checking.** Use the `virtual`, `abstract`, and\n  `override` member decorations to ensure predictable inheritance behavior, and\n  get feedback in the form of define-time errors when implementation contracts\n  are broken.\n\n## Getting Started\n\n**Typedef** is packaged with the [UMD pattern](https://github.com/umdjs/umd),\nso it can be used in the browser via a global with a `<script>` tag, on the\nserver with Node, as an AMD module with RequireJS, or with CommonJS via\n[Browserify](https://github.com/substack/node-browserify).\n\n### Building\n\nInstall all of the required modules to build and use `grunt` to build the files into the `bin/` directory:\n\n```\nnpm install\ngrunt release\n```\n\n## Defining Classes\n\nEasy peasy. Defining a class involves passing a hash of all the corresponding\nmember functions to the typedef function, as well as (optionally) naming the class.\n\n```\n// Base class definition example ....\n```\n\nIt works exactly as you might imagine.\n\n```\n// Base class instantiation and use example ...\n```\n\nNotice that the (optional) constructor function is provided via the\n`__constructor__` property in the hash.\n\nClasses are constructor functions that leverage the native prototypical\ninheritance model.\n\n### Extending Classes\n\n**Typedef** allows for single-inheritance from a base class via chaining the\n`.extends()` function in your class definition. Child constructors are\nimplicitly called, from the base up, when instantiating child classes.\n\n```\n// Child class definition example\n```\n\nChild classes can be thought of as inheriting the members of the base class--\nthough really what is going on is simply building up the native prototype\nchain.\n\n```\n// Child class use example\n```\n\n### Using Mixins\n\nMixins provide a way to add or augment existing member functions in a class.\nMultiple mixins can be used during a class definition, and the *advice*\ndecorations allow for modifying existing functions.\n\nMixins are added *after* the class is setup, meaning any wrapping augmentations\nwill be applied on top of defined members of the class.\n\nTo add a mixin to your class definition, chain the `.uses()` method in your\ndefinition.\n\n```\n// Mixin definition ...\n```\n\n### Implementing Interfaces\n\nInterfaces give you a way of specifying a required set of member functions be\npresent in a class implementation. Though this may seem superfluous for a\nduck-typed language like Javascript, this allows you run-time inspection of an\nobject's abilities with a greater degree of clarity.\n\nIn addition, using interface patterns allows for your code to be more\nself-documenting. Any discrepancy between a class and an interface it\nimplements will cause define-time exception, informing you of the issue.\n\nSpecify that a class implements a specific interface by chaining the\n`implements()` method in your class definition.\n\n```\n// Interface definition ...\n```\n\n## Inheritance Decorations\n\nThe inheritance decorations are used to govern and check the inheritance\nsemantics of your classes.\n\nAll inheritance decorations only add additional checking overhead during\ndefine time; no run-time overhead is incurred after the initial load and\ndefinition.\n\n### virtual\n\nThe `virtual` decoration follows its classical use, in that indicates a class\nmember *may* be overridden in child class. By default, all members are\nnon-virtual, and thus cannot be overridden. This effectively makes any sort of\nmember hiding in **Typedef** explicit.\n\nAttempting to override a base member that isn't virtual will result in a\ndefine-time error.\n\n### abstract\n\nAn `abstract` member is the same as a `virtual` member, with the difference\nthat a derived class *must* override the abstract member.\n\nA class with at least one abstract member is considered an abstract class. An\nexception is thrown when attempting to instantiate an abstract class.\n\n### override\n\nThe `override` decoration is required when overriding a base member in a child\nclass. The base member must be `virtual`.\n\n### new\n\nThe `new` decoration indicates that the previous implementation of a member is\nto be disregarded. This can be used to explicitly hide a base class member that\nisn't set to `virtual`, for example.\n\n### sealed\n\nA `sealed` member indicates that it cannot be override at all, even if using\nthe `new` decoration. This provides a way to very clearly indicate that a\nmember should not be changed in derived implementations of a class.\n\nAttempting to override a `sealed` member will result in a define-time\nexception.\n\n## Accessor Decorations\n\n### readonly\n\nUsing the `readonly` decoration will define the property with the `writable`\nflag set to `false`. Any attempts to update a `readonly` property will silently\nfail (unless you `use strict`).\n\nNote that this only applies for the values of members; if a member set as\n`readonly` is initialized with an object, that object can still be mutated.\n\n### static\n\n## Mixin Decorations\n\n### before\n\n### after\n\n### wrapped\n\n## Behavior-enforcing Decorations\n\n### fluent\n\nThis decoration allows you to signal in your public API that method is designed\nto returned the `this` pointer. This allows for the elegant \"fluent API\" style\nof method chaining.\n\nThe define-time check uses `function#toString` to check all return statements\nto ensure that they are returning `this`. Returning something else (or not\nhaving any `return` statements) will result in a define-time warning.\n\n## Compatibility\n\n**Typedef** makes liberal use of ES5 features such as `Object.defineProperty`\nand `Object.create`, and thus will work with any modern browser:\n\n* Chrome 7+\n* Firefox 4+\n* Safari 5.1+\n* Opera 4+\n* Internet Explorer 9+\n\n### Tests\n\nTesting is powered by [QUnit](http://qunitjs.com/) and can be run from the\ncommand line via `grunt-contrib-qunit`. To install all modules and test:\n\n```\nnpm install\ngrunt test\n```\n\n### Contributers\n\n* Brandon Valosek [@bvalosek](http://twitter.com/bvalosek)\n* Dillon Shook [dshook.is](http://dshook.is)\n\n## License\nCopyright 2013 Brandon Valosek\n\n**Typedef** is released under the MIT licenses.\n\n",
  "bugs": {
    "url": "https://github.com/bvalosek/typedef/issues"
  },
  "_id": "typedef@0.13.2",
  "dist": {
    "shasum": "9a5b65f4b65e4c079790483ddda19f800b6d186e"
  },
  "_from": "typedef@~0.13.2",
  "_resolved": "https://registry.npmjs.org/typedef/-/typedef-0.13.2.tgz"
}
