{
  "name": "infusionsoft-api",
  "version": "0.6.0",
  "description": "Javscript wrapper for the Infusionsoft API",
  "main": "index.js",
  "scripts": {
    "test": "grunt test"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:bvalosek/infusionsoft-api"
  },
  "keywords": [
    "infusionsoft",
    "api"
  ],
  "author": {
    "name": "Brandon Valosek"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/bvalosek/infusionsoft-api/issues"
  },
  "dependencies": {
    "typedef": "~0.13.2",
    "xmlrpc": "~1.1.0",
    "underscore": "~1.5.1",
    "q": "~0.9.6",
    "inflection": "~1.2.6"
  },
  "devDependencies": {
    "grunt-contrib-jshint": "~0.6.2",
    "grunt-infusionsoft": "~0.6.1"
  },
  "readme": "# Infusionsoft API\n\nA promise-driven, fluent-style Node.js wrapper for the XML-RPC [Infusionsoft API](http://help.infusionsoft.com/developers/api-basics).\n\nWrite badass Infusionsoft apps on the server that are fully and natively asynchronous.\n\nIt's pretty dope.\n\n## Usage\n\nInstall via `npm`:\n\n```\n$ npm install infusionsoft-api\n```\n\nDo cool stuff:\n\n```javascript\nvar api = require('infusionsoft-api');\n\nvar infusionsoft = new api.DataContext('myapp', 'MY_API_KEY');\n\ninfusionsoft.Contacts\n    .where(Contact.FirstName, 'Brandon')\n    .like(Contact.LastName, 'V%')\n    .select(Contact.Id, Contact.Email)\n    .orderByDescending('LastName')\n    .take(100)\n    .toArray()\n    .done(function(result) {\n        console.log(result);\n    });\n```\n\nYou can also use the API Services directly:\n\n```javascript\ninfusionsoft.ContactService\n    .findByEmail('brandon@aol.com', ['Id', 'FirstName', 'LastName']);\n```\n\nAwesome.\n\n## Promises\n\nAll asynchronous methods return a [Promise](https://github.com/kriskowal/q)\nthat represents the eventual value that will be returned.\n\nPromises are glorious and make writing heavily asynchronous code much less\nawful than it would otherwise be.\n\nSee the **More Examples** section to see them in action.\n\n\n## API Scraper\n\nThis project creates interfaces and classes for the API services and tables via\nthe [grunt-infusionsoft](http://github.com/bvalosek/grunt-infusionsoft) grunt\nplugin. To recreate the generated files, run `grunt infusionsoft`.\n\nCheck out the `infusionsoft` directory to see the output.\n\n## More Examples\n\nAll examples use `infusionsoft` as an instantiated DataContext with your app\nname and API key. ie:\n\n```javascript\nvar infusionsoft = new api.DataContext('myAppName', 'MY_API_KEY');\n```\n\n### Get monthly revenue from a particular month\n\n```javascript\ninfusionsoft.Payments\n    .like(Payment.PayDate, '2013-06%')\n    .sum(function(x) { return x.PayAmt; })\n    .done(function(total) {\n        console.log('total revenue: ' + total);\n    });\n```\n\n### Login a user and get their info\n\nAnd an example of using the `fail` method to catch any problems.\n\n```javascript\ninfusionsoft.DataService\n    .authenticateUser('user@email.com', 'md5-hash-of-password')\n    .then(function(userId) {\n        return infusionsoft.Users.where(User.Id, userId).first();\n    })\n    .then(function(user) {\n        console.log('Hello ' + user.FirstName + ' ' + user.LastName);\n    })\n    .fail(function(err) {\n        console.log('uh oh: ' + err);\n    });\n```\n\n### Get all invoices for a specific month, grouped by product\n\nUses [underscore](http://underscorejs.org/).\n\n```javascript\ninfusionsoft.Invoices\n    .like(Invoice.DateCreated, '2013-08%')\n    .groupBy(function(x) { return x.ProductSold; })\n    .done(function(result) {\n        _(result).each(function(invoices, productId) {\n            console.log(productId, invoices.length);\n        });\n    });\n```\n\nSame as above, but use the `spread` function to wait on 2 promises to get the\ncorresponding product names. The API hits for querying both the `Product` table\nand the `Invoice` table will actually fire off at the same time.\n\nHashtag asynchronous.\n\n```javascript\nvar products = infusionsoft.Products.toArray();\nvar invoices = infusionsoft.Invoices\n    .like(Invoice.DateCreated, '2013-08%')\n    .groupBy(function(x) { return x.ProductSold; });\n\nQ.spread([products, invoices], function(products, invoices) {\n   _(invoices).each(function(invoices, productId)  {\n        var productName = _(products)\n            .find(function(x) { return x.Id == productId; })\n            .ProductName;\n\n        console.log(productName, invoices.length);\n   });\n});\n```\n\n### From an email address, get a contact's tags\n\n```javascript\nsdk.Contacts\n    .where(Contact.Email, 'some@email.com')\n    .first()\n    .then(function(contact) {\n        return sdk.ContactGroupAssigns\n            .where(ContactGroupAssign.ContactId, contact.Id)\n            .toArray();\n    })\n    .then(function(cgas) {\n        cgas.forEach(function(group) {\n            console.log(group.ContactGroup, group.DateCreated);\n        });\n    });\n```\n\n### Get the full Product Category Name for all subscription plans\n\nOkay, take a deep breath. We can do (inner) joins. We fake it though... the\n`inner` part of the join has to be loaded entirely and then we do a `O(n^2)`\niteration to make it, but we can still do it. If the `inner` is cheap, this\nisn't too bad. Especially when the SDK will handle loading, paging, waiting,\netc... all for you.\n\nSyntax (stolen from C#'s LINQ):\n\n### `join` (`innerQueryable`, `outerKey`, `innerKey`, `selectorFn`)\n\nLet's do this:\n\n\n```javascript\nvar pc    = infusionsoft.ProductCategories;\nvar pca   = infusionsoft.ProductCategoryAssigns;\nvar plans = infusionsoft.SubscriptionPlans;\n\n// Join the categories onto itself for creating the full category name\n// (category parent name + category name)\nvar categories = pc\n    .join(pc, 'ParentId', 'Id', function(pc, parent) {\n        return {\n            Id: pc.Id,\n            Name: parent.CategoryDisplayName + ' ' + pc.CategoryDisplayName\n        }; });\n\nvar subPlans = plans\n\n    // Join the sub plan (which only has product Id) onto the PCA table to get\n    // the product category ID\n    .join(pca, 'ProductId', 'ProductId', function(plan, pca) {\n        plan.ProductCategoryId = pca.ProductCategoryId;\n        return plan;\n    })\n\n\n    // Join our categories object we made above onto the projection from the\n    // most recent join to get the full category name + subscription plan Id\n    .join(categories, 'ProductCategoryId', 'Id', function(plan, category) {\n        return { planId: plan.Id, category: category.Name }; });\n\nsubPlans.toArray().done(function(d) { console.log(d); });\n```\n\nWhat happens magically behind the scenes is pretty nice. When we call\n`toArray()` at the end, we first query the SubscriptionPlan table (aliased as\n`plans`). It then knows we need to join the `ProductCategoryAssign` table on\nthere, so it fetches that (which may be more than one page). It finally gets\nthe `ProductCategory` table (in its entirety), and joins them all up.\n\nThe syntax looks nasty, but that is somewhat unavoidable with a `join`\nfunction.\n\n\n## License\nCopyright 2013 Brandon Valosek\n\n**Infusionsoft API** is released under the MIT license.\n\n",
  "readmeFilename": "README.md",
  "_id": "infusionsoft-api@0.6.0",
  "dist": {
    "shasum": "fbac3b378e8b15ac6293133ccf073473f11d78d1"
  },
  "_from": "infusionsoft-api@",
  "_resolved": "https://registry.npmjs.org/infusionsoft-api/-/infusionsoft-api-0.6.0.tgz"
}
